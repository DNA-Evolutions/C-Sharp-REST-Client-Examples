/*
 * DNA Evolutions - JOpt.TourOptimizer
 *
 * This is DNA's JOpt.TourOptimizer service. A RESTful Spring Boot application using springdoc-openapi and OpenAPI 3. JOpt.TourOpptimizer is a service that delivers route optimization and automatic scheduling features to be easily integrated into any third-party application. JOpt.TourOpptimizer encapsulates all necessary optimization functionality and provides a comprehensive REST API that offers a domain-specific optimization interface for the transportation industry. The service is stateless and does not come with graphical user interfaces, map depiction or any databases. These extensions and adjustments are supposed to be introduced by the consumer of the service while integrating it into his/her own application. The service will allow for many suitable adjustments and user-specific settings to adjust the behaviour and optimization goals (e.g. minimizing distance, maximizing resource utilization, etc.) through a comprehensive set of functions. This will enable you to gain control of the complete optimization processes.This service is based on JOpt (7.5.1-SNAPSHOT)
 *
 * The version of the OpenAPI document: 1.2.1-SNAPSHOT
 * Contact: info@dna-evolutions.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using FileParameter = Org.OpenAPITools.Client.FileParameter;
using OpenAPIDateConverter = Org.OpenAPITools.Client.OpenAPIDateConverter;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// The header of the solution per route is summarizing important data like number of elements in the route , total time needed for the route etc.
    /// </summary>
    [DataContract(Name = "RouteHeader")]
    public partial class RouteHeader : IEquatable<RouteHeader>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteHeader" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected RouteHeader() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="RouteHeader" /> class.
        /// </summary>
        /// <param name="cost">The abstract cost value of the route. (required).</param>
        /// <param name="time">The time that is needed for the route. (required).</param>
        /// <param name="idleTime">The accumlated idleTime of the route. (required).</param>
        /// <param name="prodTime">The productive time of the route. Productive time is working-time spend at a node. (required).</param>
        /// <param name="tranTime">The tranTime. The summed transit time of the route. (required).</param>
        /// <param name="termiTime">The termiTime. The time taken from the last element to the termination element of the route. (required).</param>
        /// <param name="distance">The distance. The summed transit distance of the route. (required).</param>
        /// <param name="termiDistance">The termiDistance. The distance taken from the last element to the termination element of the route. (required).</param>
        /// <param name="routeViolations">The routeViolations. Violations that occur on route level. For example, overtime, overdistance etc. (required).</param>
        /// <param name="isClosed">The isClosed boolean describes if a Resource has to visit the termination element of the Route. By default, the start element and the termination element of a Route is the Resource itself. In case of a closed route, by default, the Resource returns to its original starting location. (required).</param>
        /// <param name="isAlternateDestination">The isAlternateDestination boolean. Descibes of the Resource has an alternate destination. The Resource has to end it&#39;s Route at the alternate destination there but  will start from the original route start again the next working hour. (required).</param>
        public RouteHeader(double cost = default(double), string time = default(string), string idleTime = default(string), string prodTime = default(string), string tranTime = default(string), string termiTime = default(string), string distance = default(string), string termiDistance = default(string), List<Violation> routeViolations = default(List<Violation>), bool isClosed = default(bool), bool isAlternateDestination = default(bool))
        {
            this.Cost = cost;
            // to ensure "time" is required (not null)
            if (time == null)
            {
                throw new ArgumentNullException("time is a required property for RouteHeader and cannot be null");
            }
            this.Time = time;
            // to ensure "idleTime" is required (not null)
            if (idleTime == null)
            {
                throw new ArgumentNullException("idleTime is a required property for RouteHeader and cannot be null");
            }
            this.IdleTime = idleTime;
            // to ensure "prodTime" is required (not null)
            if (prodTime == null)
            {
                throw new ArgumentNullException("prodTime is a required property for RouteHeader and cannot be null");
            }
            this.ProdTime = prodTime;
            // to ensure "tranTime" is required (not null)
            if (tranTime == null)
            {
                throw new ArgumentNullException("tranTime is a required property for RouteHeader and cannot be null");
            }
            this.TranTime = tranTime;
            // to ensure "termiTime" is required (not null)
            if (termiTime == null)
            {
                throw new ArgumentNullException("termiTime is a required property for RouteHeader and cannot be null");
            }
            this.TermiTime = termiTime;
            // to ensure "distance" is required (not null)
            if (distance == null)
            {
                throw new ArgumentNullException("distance is a required property for RouteHeader and cannot be null");
            }
            this.Distance = distance;
            // to ensure "termiDistance" is required (not null)
            if (termiDistance == null)
            {
                throw new ArgumentNullException("termiDistance is a required property for RouteHeader and cannot be null");
            }
            this.TermiDistance = termiDistance;
            // to ensure "routeViolations" is required (not null)
            if (routeViolations == null)
            {
                throw new ArgumentNullException("routeViolations is a required property for RouteHeader and cannot be null");
            }
            this.RouteViolations = routeViolations;
            this.IsClosed = isClosed;
            this.IsAlternateDestination = isAlternateDestination;
        }

        /// <summary>
        /// The abstract cost value of the route.
        /// </summary>
        /// <value>The abstract cost value of the route.</value>
        [DataMember(Name = "cost", IsRequired = true, EmitDefaultValue = false)]
        public double Cost { get; set; }

        /// <summary>
        /// The time that is needed for the route.
        /// </summary>
        /// <value>The time that is needed for the route.</value>
        [DataMember(Name = "time", IsRequired = true, EmitDefaultValue = false)]
        public string Time { get; set; }

        /// <summary>
        /// The accumlated idleTime of the route.
        /// </summary>
        /// <value>The accumlated idleTime of the route.</value>
        [DataMember(Name = "idleTime", IsRequired = true, EmitDefaultValue = false)]
        public string IdleTime { get; set; }

        /// <summary>
        /// The productive time of the route. Productive time is working-time spend at a node.
        /// </summary>
        /// <value>The productive time of the route. Productive time is working-time spend at a node.</value>
        [DataMember(Name = "prodTime", IsRequired = true, EmitDefaultValue = false)]
        public string ProdTime { get; set; }

        /// <summary>
        /// The tranTime. The summed transit time of the route.
        /// </summary>
        /// <value>The tranTime. The summed transit time of the route.</value>
        [DataMember(Name = "tranTime", IsRequired = true, EmitDefaultValue = false)]
        public string TranTime { get; set; }

        /// <summary>
        /// The termiTime. The time taken from the last element to the termination element of the route.
        /// </summary>
        /// <value>The termiTime. The time taken from the last element to the termination element of the route.</value>
        [DataMember(Name = "termiTime", IsRequired = true, EmitDefaultValue = false)]
        public string TermiTime { get; set; }

        /// <summary>
        /// The distance. The summed transit distance of the route.
        /// </summary>
        /// <value>The distance. The summed transit distance of the route.</value>
        [DataMember(Name = "distance", IsRequired = true, EmitDefaultValue = false)]
        public string Distance { get; set; }

        /// <summary>
        /// The termiDistance. The distance taken from the last element to the termination element of the route.
        /// </summary>
        /// <value>The termiDistance. The distance taken from the last element to the termination element of the route.</value>
        [DataMember(Name = "termiDistance", IsRequired = true, EmitDefaultValue = false)]
        public string TermiDistance { get; set; }

        /// <summary>
        /// The routeViolations. Violations that occur on route level. For example, overtime, overdistance etc.
        /// </summary>
        /// <value>The routeViolations. Violations that occur on route level. For example, overtime, overdistance etc.</value>
        [DataMember(Name = "routeViolations", IsRequired = true, EmitDefaultValue = false)]
        public List<Violation> RouteViolations { get; set; }

        /// <summary>
        /// The isClosed boolean describes if a Resource has to visit the termination element of the Route. By default, the start element and the termination element of a Route is the Resource itself. In case of a closed route, by default, the Resource returns to its original starting location.
        /// </summary>
        /// <value>The isClosed boolean describes if a Resource has to visit the termination element of the Route. By default, the start element and the termination element of a Route is the Resource itself. In case of a closed route, by default, the Resource returns to its original starting location.</value>
        [DataMember(Name = "isClosed", IsRequired = true, EmitDefaultValue = true)]
        public bool IsClosed { get; set; }

        /// <summary>
        /// The isAlternateDestination boolean. Descibes of the Resource has an alternate destination. The Resource has to end it&#39;s Route at the alternate destination there but  will start from the original route start again the next working hour.
        /// </summary>
        /// <value>The isAlternateDestination boolean. Descibes of the Resource has an alternate destination. The Resource has to end it&#39;s Route at the alternate destination there but  will start from the original route start again the next working hour.</value>
        [DataMember(Name = "isAlternateDestination", IsRequired = true, EmitDefaultValue = true)]
        public bool IsAlternateDestination { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class RouteHeader {\n");
            sb.Append("  Cost: ").Append(Cost).Append("\n");
            sb.Append("  Time: ").Append(Time).Append("\n");
            sb.Append("  IdleTime: ").Append(IdleTime).Append("\n");
            sb.Append("  ProdTime: ").Append(ProdTime).Append("\n");
            sb.Append("  TranTime: ").Append(TranTime).Append("\n");
            sb.Append("  TermiTime: ").Append(TermiTime).Append("\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  TermiDistance: ").Append(TermiDistance).Append("\n");
            sb.Append("  RouteViolations: ").Append(RouteViolations).Append("\n");
            sb.Append("  IsClosed: ").Append(IsClosed).Append("\n");
            sb.Append("  IsAlternateDestination: ").Append(IsAlternateDestination).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RouteHeader);
        }

        /// <summary>
        /// Returns true if RouteHeader instances are equal
        /// </summary>
        /// <param name="input">Instance of RouteHeader to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RouteHeader input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.Cost == input.Cost ||
                    this.Cost.Equals(input.Cost)
                ) && 
                (
                    this.Time == input.Time ||
                    (this.Time != null &&
                    this.Time.Equals(input.Time))
                ) && 
                (
                    this.IdleTime == input.IdleTime ||
                    (this.IdleTime != null &&
                    this.IdleTime.Equals(input.IdleTime))
                ) && 
                (
                    this.ProdTime == input.ProdTime ||
                    (this.ProdTime != null &&
                    this.ProdTime.Equals(input.ProdTime))
                ) && 
                (
                    this.TranTime == input.TranTime ||
                    (this.TranTime != null &&
                    this.TranTime.Equals(input.TranTime))
                ) && 
                (
                    this.TermiTime == input.TermiTime ||
                    (this.TermiTime != null &&
                    this.TermiTime.Equals(input.TermiTime))
                ) && 
                (
                    this.Distance == input.Distance ||
                    (this.Distance != null &&
                    this.Distance.Equals(input.Distance))
                ) && 
                (
                    this.TermiDistance == input.TermiDistance ||
                    (this.TermiDistance != null &&
                    this.TermiDistance.Equals(input.TermiDistance))
                ) && 
                (
                    this.RouteViolations == input.RouteViolations ||
                    this.RouteViolations != null &&
                    input.RouteViolations != null &&
                    this.RouteViolations.SequenceEqual(input.RouteViolations)
                ) && 
                (
                    this.IsClosed == input.IsClosed ||
                    this.IsClosed.Equals(input.IsClosed)
                ) && 
                (
                    this.IsAlternateDestination == input.IsAlternateDestination ||
                    this.IsAlternateDestination.Equals(input.IsAlternateDestination)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = (hashCode * 59) + this.Cost.GetHashCode();
                if (this.Time != null)
                {
                    hashCode = (hashCode * 59) + this.Time.GetHashCode();
                }
                if (this.IdleTime != null)
                {
                    hashCode = (hashCode * 59) + this.IdleTime.GetHashCode();
                }
                if (this.ProdTime != null)
                {
                    hashCode = (hashCode * 59) + this.ProdTime.GetHashCode();
                }
                if (this.TranTime != null)
                {
                    hashCode = (hashCode * 59) + this.TranTime.GetHashCode();
                }
                if (this.TermiTime != null)
                {
                    hashCode = (hashCode * 59) + this.TermiTime.GetHashCode();
                }
                if (this.Distance != null)
                {
                    hashCode = (hashCode * 59) + this.Distance.GetHashCode();
                }
                if (this.TermiDistance != null)
                {
                    hashCode = (hashCode * 59) + this.TermiDistance.GetHashCode();
                }
                if (this.RouteViolations != null)
                {
                    hashCode = (hashCode * 59) + this.RouteViolations.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.IsClosed.GetHashCode();
                hashCode = (hashCode * 59) + this.IsAlternateDestination.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        public IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
